# Условия заданий

## Общие места

Решения присылаются в Telegram @donRumata03 или @sitandr.
Можно объединяться в команды, но не больше двух человек.

Код тестов корректности будет доступен для заданий 1 и 3.
Кроме этого, некоторые решения могут быть признаны `читерными` в ручном режиме — и правила игры могут быть обновлены.


## 1. Анализ проблем транспортировки вещества в жидком агрегатном состоянии в сосудах с перфорированным дном

> Перенос воды в решете — тут всё будет мутировать, как будто "вытекая из рук"

### Entropy

Представьте себе, что случилось непоправимое. Больше ни в одной программе нельзя доверять хранимым данным. Из-за нового компьютерного вируса/мощнейшего выплеска радиации/нового сверхбыстрого метода вычислений (выберете лор на вкус) *все переменные*, которые Вы храните в программе, начинают меняться. Сможете ли Вы выжить в этом безумном мире? Сможете ли придумать способ, как что-то точно посчитать?

Задача — максимально точно вычислить число π на языке `Entropy`.

Оригинальный `Entropy` — мелкий `concept-of-art` "компилятор" на C# на старых версиях `.Net` (4.x). В самом языке очень мало команд, буквально вещественные числа, циклы-ифы и вывод. Язык **не** тьюринг-полный. Для этой задачи мне пришлось капельку доработать компилятор и язык, чтобы задача была вообще выполнима, поэтому рекомендую смотреть мой [форк](https://github.com/sitandr/Entropy) (краткая документация к языку прилагается, в отличие от оригинальной версии). В отдельной ветке лежит код, обновленный до новых версий `.Net` — ценой удобства и производительности их можно запускать на `Linux` (в README написано, как).

Каждый раз, когда происходит обращение к переменной, она случайным образом (кстати, криптографически стойким) меняется на значение до `(m·10)%`, где m — уровень «тряски», температура, оно же `mutation rate`.

Итак, формулировка задачи:

- Необходимо прислать один файл `.en`, который будет выдавать на выходе число, как можно более близкое к числу π.
- Во время челледжа *можно* просить добавить в компилятор недостающую базовую функцию, не нарушающую концепции языка и не превращающую задачу в тривиальную (а еще можно добавить её самим, предварительно обговорив — это плюс в карму).
- Запрещается использовать "захардкоженые" константы, кроме целых чисел, которые по понятным свойствам вытекают из свойств числа π.
- Программе заранее неизвестен текущий уровень мутаций (но никто не мешает его вычислить экспериментально).

Решение может быть специализировано на одном из фиксированных уровней мутаций:

1. Сверхмалые мутации. Мутации от 10⁻⁴% до 10⁻²% от числа.
2. Умеренные мутации. От 10⁻² до 1%.
3. Мощные мутации. От 1% до 30%.

Каждый уровень имеет свой `Leaderboard` — можно выбрать понравившийся уровень неопределенности, забыв про требования к остальным. Лидеру в каждой области (при условии, что будет больше двух соревнующихся) — по шоколадному батончику, если кто-то создаст программу, которая превзойдет все остальные во всех областях — дополнительная вкусняшка.

**Важно:** При отключенных мутациях программа должна выдавать число пи с относительной погрешностью не более `10⁻⁴`.

В этом репозитории лежит код на питоне, который строит график точности в указанных уровнях мутации. Его мы и будем использовать, когда будем определять победителя. Им *нужно* пользоваться для построения лучшего решения.

**P.S.** Ребятам с Линуксом рекомендую не морочиться (можно попытаться, но успех не гарантирую, очень много факторов) и присылать код @sitandr, я протестирую и пришлю графики. Если хочется иметь локально — нужно проставить дополнительный флаг в коде и заменить исполняемый файл на файлы из Standalone Build-а (весит 150Mb, так что проще скомпилить самому по [инструкции](https://github.com/sitandr/Entropy/tree/net7#build), чем качать файл).


## 2. Закономерности соотношения длины ороговевшего пидермиса с количеством серого вещества в черепной коробке

> Волос долог, да ум короток

> Оно же "Отсутствие прогресса-регресса в метаболизме организма при изменении соотношения жиров и углеводов в традиционном блюде оседлых народов" (кашу маслом не испортишь)

Вам будет выдан `a piece of very старательно обфусцированный код`.

Ваша задача — реализовать функцию с такой же сигнатурой и поведением,
как у оригинальной, но _**с асимптотической оптимизацией**_.

Система тестирования корректности спойлерит решение, поэтому она доступна не будет (но она есть!).

Проверка наличия асимптотической оптимизации будет производиться вручную (это может быть подсказкой).

Задача, которую решает код, неизвестна. :)

## 3. Закономерность возрастания личностной ценности субъекта после получения травматического опыта

> За одного битого двух небитых дают

> Штирлиц поругался с посетителем бара и вышел с ним 1 на 1. На выходе он увидел 8 человек с битами. "Один байт это 8 бит", — подумал Штирлиц.

> Оно же "Положительное воздействие низкого коффициента интеллекта на
увеличение совокупности задач в процессе осуществления трудовой деятельности" («работа дураков любит»)

**Code golf** на `C`.

В наши тяжёлые времена в каждом уважающем себя курсе выживания учат составлять
функциональные схемы из логических элементов, а их — из транзисторов.

Однако мы пойдём дальше и… напишем код на `C`… С [небольшими ограничениями](https://www.youtube.com/watch?v=yeqYNOFQDVU)…

1. Циклы (даже через `goto`) запрещены.
2. Нельзя использовать арифметические операции (даже `++`, `--` и операторы сравнения).
3. Требуется _минимизмировать длину кода в символах_ (пробельные символы не считаются).

Что же надо сделать? Ну, это не столь важно. Давайте что-нибудь фиксированное…

Например,

- функцию `u8 add(u8 a, u8 b)`, складывающую числа (и возвращающую младший байт),
- функцию `u8 mul(u8 a, u8 b)`, умножающую числа (и возвращающую младший байт),
- функцию `u8 int_sqrt(u8 a, u8 b)`, вычисляющую квадратный корень с округлением вниз.

Разрешается в качестве промежуточных типов использовать более старшие (до `uint64_t` ‹—› `u64`).
(Алиасы типов будут предоставлены заранее)

Числа специально маленькие, чтобы было бо́льшее количество разных способов,
выдерживающих конкуренцию и соревнование было интереснее.

Список требований может расширяться по ~~диктаторской воле~~ решению большинством голосов жюри 
— чтобы ~~стереть с лица земли плоды креатива, не угладывающиеся в голове жюри и не предусмотренные заранее~~
предотвратить совсем наглое читерство.

Код системы тестирования _корректности_ кода будет доступна каждому участнику в течение всего соревнования (можно запускать у себя).

Победитель: участник с минимальным количеством символов из тех, чья программа корректна.
